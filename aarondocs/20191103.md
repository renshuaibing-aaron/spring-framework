1. 关于@Configruation 的使用，spring 在扫描时会进行一下判断
```java
		//判断当前这个bd中存在的类是不是加了@Configruation注解
		//如果存在则spring认为他是一个全注解的类
		if (isFullConfigurationCandidate(metadata)) {
			//如果存在Configuration 注解,则为BeanDefinition 设置configurationClass属性为full
			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);
		}
		//判断是否加了以下注解，摘录isLiteConfigurationCandidate的源码
		//     candidateIndicators.add(Component.class.getName());
		//		candidateIndicators.add(ComponentScan.class.getName());
		//		candidateIndicators.add(Import.class.getName());
		//		candidateIndicators.add(ImportResource.class.getName());
		//如果不存在Configuration注解，spring则认为是一个部分注解类
		else if (isLiteConfigurationCandidate(metadata)) {
			beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);
		}
```

2.解析java 包内的东西

```java
	protected Set<BeanDefinitionHolder> doScan(String... basePackages) {
		Assert.notEmpty(basePackages, "At least one base package must be specified");
		Set<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<>();
		for (String basePackage : basePackages) {
			//扫描basePackage路径下的java文件
			//符合条件的并把它转成BeanDefinition类型
			Set<BeanDefinition> candidates = findCandidateComponents(basePackage);
```

3.@Import注解的作用




4.spring针对不同的类的注册方式不同


5. @Configuation总结

 @Configuation等价于<Beans></Beans>

 @Bean等价于<Bean></Bean>

 @ComponentScan等价于<context:component-scan base-package="com.dxz.demo"/>